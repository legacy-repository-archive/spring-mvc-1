동시 요청 - 멀티 쓰레드  
=========================   

# 개요 
    
![servlet-thread](https://user-images.githubusercontent.com/50267433/126514569-41fed000-e08f-4d25-8b93-0049a603d48b.PNG)      
      
클라이언트에서 서버(WAS)로 요청을 보내면  
클라이언트와 서버(WAS)는 `TCP/IP 커넥션 연결`이 된다. (3Way Hand Shake)      
     
이후, 서버(WAS)는 `Servlet`을 통해 결과값을 얻고 이를 클라이언트에 반환해준다.        
그런데 한 가지 의문점이 `Servlet`에 대해서 우리는 단순히 정의만 해주었는데      
**`누가` Servlet을 객체로 만들고 이를 호출하여 사용하는 것일까? 🤔**     

이에 대한 해답으로 **쓰레드**라고 말할 수 있다.  
     
# 쓰레드        
실행 중인 프로그램을 우리는 프로세스라고 말을 한다.              
하나의 프로세스는 여러 작은 단위의 쓰레드를 가질 수 있다.            
      
쓰레드는, 애플리케이션 코드를 하나하나 순차적으로 실행하는 역할을 하고 있다.       
가장 적절한 비유로 우리가 기본적으로 사용하는 `main()` 메서드도 `Main 쓰레드`에 의해 실행된다.         
이말은 곧, 쓰레드가 없다면 자바 애플리케이션은 수행이 불가능하다는 것을 의미한다.     
     
**쓰레드는 한번에 하나의 코드 라인만을 수행한다.**      
그렇기에 **동시에 여러 요청이 온다면 쓰레드를 추가로 생성해줘야 한다.**        

## 단일 쓰레드 단일 요청
     
![single-thread-rest](https://user-images.githubusercontent.com/50267433/126514674-5e45fabe-5b2c-4908-808a-10bf8ad8f4ed.PNG)  
![single-thread-active](https://user-images.githubusercontent.com/50267433/126514702-3ae30c74-e4f3-4bc3-a6cd-3e12f153bde9.PNG)   
![single-thread-response](https://user-images.githubusercontent.com/50267433/126514717-fb3048cd-d2aa-4d57-8e08-c742870014ba.PNG)  
![single-thread-final](https://user-images.githubusercontent.com/50267433/126514726-65a68f70-7e5f-4a38-942e-5e7a6426efca.PNG)   
       
쓰레드가 1개만 있다고 가정을 한다.     
클라이언트에서 요청이 오면, WAS 에서는 쓰레드 한 개를 할당을 해서 요청을 처리하도록 한다.    
물론, 요청을 처리한다는 말은 Servlet 을 구동시켜 클라이언트에게 알맞은 응답을 주기 위해 애플리케이션 로직을 실행하는 것이다.     
  
## 단일 쓰레드 다중 요청  
     
![multi-thread-one-active-delay-error-thread](https://user-images.githubusercontent.com/50267433/126516876-677bfbf5-9b00-4577-bf9e-4725d48dad82.PNG)    
      
쓰레드는 1개인데 여러 요청이 왔다고 가정한다.        
하나의 쓰레드는 하나의 요청만 처리할 수 있기 때문에 나머지 한 개의 요청은 대기가 된다.       
        
**그런데 만약,** 로직에 문제가 있어 응답 처리 시간이 지연이 된다면        
나머지 요청은 무기한 대기상태에 빠지게 되고    
**timeout 마저 지나면** 2개의 요청 모두 연결이 끊겨 응답이 실패하게 된다.         
   
![multi-thread-one-active-new--another-thread](https://user-images.githubusercontent.com/50267433/126516908-e5acb14c-fa65-4b1e-af3a-36f2cf163de5.PNG)     
    
위 같은 문제를 해결하기 위한 가장 쉬운 방법은 쓰레드를 새로 생성해서 할당하는 것이다.      

## 요청 마다 쓰레드 생성의 장단점  
**장점**   
* 동시 요청 처리를 할 수 있다.    
* 리소스(CPU, 메모리)가 허용할 때 까지 처리 가능(단 넘치면 다 죽는다.)       
* 하나의 쓰레드가 지연되어도, 나머지 쓰레드는 정상 동작한다.     
  
**단점**       
* **쓰레드 생성 비용은 매우 비싸다**      
  즉, 고객의 요청이 올 때 마다 쓰레드를 생성하면, 응답 속도가 느려진다.    
* **쓰레드는 컨텍스트 스위칭 비용이 발생한다.**      
  사실 CPU는 코어의 갯수 만큼의 쓰레드를 처리할 수 있다. (4코어는 -> 4개의 쓰레드 각각 맡아 동시에 돌린다.)      
  만약, 4코어 기준 8개의 쓰레드를 돌린다면      
  매우 빠른 속도로 CPU는 4개의 쓰레드를 처리하다가 다시 다른 4개의 쓰레드를 바꾸어서 처리하고 이를 반복한다.        
  이렇듯 CPU가 맡은 작업이 전환되는 것을 컨텍스트 스위칭이라하는데 쓰레드가 많을 수록 이 비용이 커진다.(많이 교체하니까)        
* **쓰레드 생성에 제한이 없다.**    
  고객 요청이 너무 많이 오면, CPU/메모리 임계점을 넘어서 서버가 죽을 수 있다.    

## 쓰레드 풀(해결 방법)   
`쓰레드 풀`은 WAS 내부에 존재하며, 쓰레드를 미리 만들어 대기시켜놓았다가      
쓰레드를 필요로 할 때 꺼내서 CPU에게 할당을 해주는 기술을 의미한다.       

![multi-thread-thread-pool](https://user-images.githubusercontent.com/50267433/126516977-2fe9c784-f8f7-4a8d-87b9-b23272d80779.PNG)  
![thread-pool-active](https://user-images.githubusercontent.com/50267433/126517092-d1196ac5-40b4-4548-bf5a-00d4b92aa379.PNG)       
    
즉, 쓰레드를 미리 만들기에 `매번 생성하는 비용(시간)을 줄이고`     
쓰레드의 갯수 제한도 두어 `리소스를 넘기는 것을 방지` 할 수도 있다.   
    
**그렇다면 쓰레드 풀의 갯수도 초과한 요청이 온다면..? 🤔**     
나머지 요청들은 `대기 제한 수`만큼 대기하고 또 그외 나머지는 연결이 거부된다.   

 
**정리**      
* 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.  
* 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. (톰캣은 최대 200개 기본 설정-변경가능)       
   
**사용**  
* 쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다.   
* 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.   
* 최대 쓰레드가 모두 사용중이어서 쓰레드 풀에 쓰레드가 없다면?   
    * 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정할 수 있다.  
   
**장점**   
* 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답시간이 빠르다.     
* 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.    

### 실무 팁 
WAS 의 주요 튜닝 포인트는 최대 쓰레드 갯수이다.   

* 이 값을 너무 낮게 설정하면?   
    * 동시 요청이 많으면, 서버 리소스는 여유롭지만 클라이언트는 금방 응답 지연 
      최소 50%는 사용하고 평균 `70%`은 사용하는 것 같다. 

* 이 값을 너무 높게 설정하면?   
    * 동시 요청이 많으면, CPU/메모리 리소스 임계점 초과로 서버 다운이된다.     
    * 즉, 한계 범위를 모르기에 너무 높은 값으로 설정했다가 서버가 다운이된다.         
  
* 장애 발생시?   
    * 클라우드면 일단 서버를 늘리고, 이후에 튜닝한다.   
    * 클라우드가 아니면 열심히 튜닝한다.   

**쓰레드 풀의 적정 숫자**    
* 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다르다.   
* 성능 테스트 
    * 최대한 실제 서비스와 유사하게 성능 테스트 시도   
    * 툴 : 아파치 ab, Jmeter, nGrinder 등등이 있다.   

#### 내가 배운 Thread 갯수 선정하기 
   
**CPU 모델명**
```sh
$ cat /proc/cpuinfo | grep "model name" | uniq -c | awk '{print $5 $6, $7,$8, $9, $10 $11}'
```  
  
**CPU당 물리 코어 수**   
```sh
$ cat /proc/cpuinfo | grep "cpu cores" | tail -1 | awk '{print $4}'
```

**물리 CPU 수**
```
$ cat /proc/cpuinfo | grep "physical id" | sort -u | wc -l
```  
  
**리눅스 전체 코어(프로세스)개수**    
```sh
$ grep -c processor /proc/cpuinfo
```

**적절한 스레드 수** = `사용 가능한 코어 수` * `(1+대기 시간/서비스 시간)` 
즉, 적절한 스레드 수는 **사용 가능한 코어 수의 1 ~ 2 배 내로 수렴한다.**      
        
**대기 시간**은 I/O waiting, 원격 서비스에 대한 HTTP response wating 등 작업 하나가 완료되기까지 소모되는 시간을 의미한다.    
CPU를 많이 쓰는 계산 작업의 경우 대기를 거의 하지 않으므로 (대기 시간/서비스 시간)의 값이 0에 수렴한다.       
이 경우, 스레드의 수는 사용 가능한 코어의 수와 동일하다.       

```java
@Configuration 
@EnableAsync 
public class AsyncThreadConfig { 

    @Bean 
    public Executor asyncThreadTaskExecutor() { 
        ThreadPoolTaskExecutor exexcutor = new ThreadPoolTaskExecutor();     
        /* 기본 Thread 사이즈 */
        exexcutor.setCorePoolSize(2); 
        /* 최대 Thread 사이즈 */        
        exexcutor.setMaxPoolSize(4); 
        /* MaxThread가 동작하는 경우 대기하는 Queue 사이즈 */                
        exexcutor.setQueueCapacity(100)
        exexcutor.setThreadNamePrefix("subway-async-"); 
        return exexcutor; 
    } 
}
```

# WAS의 멀티 쓰레드 지원   
  
* 멀티쓰레드에 대한 부분은 WAS가 처리  
* **개발자가 멀티 쓰레드 관련 코드를 신경쓰지 않아도 된다.**  
* **개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발한다.**   
* 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)은 주의해서 사용해야한다.     
    * 쓰레드는 특성상 자원을 공유하기에 JVM의 메모리도 공유한다.   
    * 특히 `객체`에 대해서 공유 효과가 일어나기에 **싱글톤 객체들은 공유 변수를 조심해야한다.**    
    




     
  

 




  
  
  






